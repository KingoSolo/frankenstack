import { db } from '../db/client';
import { adapters, type Adapter, type NewAdapter } from '../db/schema/adapters';
import { eq } from 'drizzle-orm';
import * as fs from 'fs';
import * as path from 'path';

export class AdapterService {
  // Generate adapter code using Kiro's template
  private async generateAdapterCode(
  sourceProtocol: string,
  targetProtocol: string,
  config: any
): Promise<string> {
  // Determine which template to use
  let templatePath: string | null = null;
  
  if (sourceProtocol === 'REST' && targetProtocol === 'GraphQL') {
    templatePath = path.join(__dirname, '../templates/rest-to-graphql.js');
  } else if (sourceProtocol === 'GraphQL' && targetProtocol === 'REST') {
    templatePath = path.join(__dirname, '../templates/graphql-to-rest.js');
  }
  
  // Load template if it exists
  if (templatePath && fs.existsSync(templatePath)) {
    let template = fs.readFileSync(templatePath, 'utf-8');
    
    // Customize template with user config
    template = this.customizeTemplate(template, config);
    
    return template;
  }
  
  // Fallback: Generate basic adapter structure
  return this.generateFallbackAdapter(sourceProtocol, targetProtocol, config);
}
  
  // Customize template with user-specific config
  private customizeTemplate(template: string, config: any): string {
    let customized = template;
    
    // Add config as a comment at the top
    const configComment = `
/**
 * Adapter Configuration
 * Generated by FrankenStack with Kiro
 * 
 * Source: ${config.sourceProtocol}
 * Target: ${config.targetProtocol}
 * Input Method: ${config.inputMethod}
 * 
 * User Description:
 * ${config.description || 'N/A'}
 * 
 * Endpoints:
 * Source: ${config.sourceEndpoint || 'N/A'}
 * Target: ${config.targetEndpoint || 'N/A'}
 */
`;
    
    customized = configComment + '\n' + customized;
    
    // TODO: In future, replace placeholder values in template with actual config
    // For now, template is generic and configurable via the config parameter
    
    return customized;
  }
  
  // Fallback adapter for unsupported protocol combinations
  private generateFallbackAdapter(source: string, target: string, config: any): string {
    return `
/**
 * ${source} to ${target} Adapter
 * Generated by FrankenStack with Kiro
 * 
 * Note: This is a placeholder adapter.
 * Full implementation for ${source}â†”${target} coming soon!
 */

async function adapter${source}To${target}(payload, config) {
  console.log('Received ${source} payload:', payload);
  console.log('Target ${target} endpoint:', config.targetEndpoint);
  
  // TODO: Implement ${source} to ${target} transformation
  // This would be generated by Kiro based on user's specific requirements
  
  return {
    success: false,
    error: 'This protocol combination is not yet implemented',
    message: 'Please add support for ${source} to ${target} adapters'
  };
}

module.exports = { adapter${source}To${target} };
`;
  }

  // Create adapter with generated code
  async createAdapter(data: Omit<NewAdapter, 'id' | 'createdAt' | 'updatedAt'>): Promise<Adapter> {
    // Generate code using Kiro's template
    const generatedCode = await this.generateAdapterCode(
      data.sourceProtocol,
      data.targetProtocol,
      data.config
    );
    
    // Save to database with generated code
    const [adapter] = await db.insert(adapters).values({
      ...data,
      code: generatedCode
    }).returning();
    
    return adapter;
  }

  // Get one adapter by ID
  async getAdapter(id: string): Promise<Adapter | undefined> {
    return await db.query.adapters.findFirst({
      where: eq(adapters.id, id)
    });
  }

  // Get all adapters for a user
  async listAdapters(userId: string): Promise<Adapter[]> {
    return await db.query.adapters.findMany({
      where: eq(adapters.userId, userId),
      orderBy: (adapters, { desc }) => [desc(adapters.createdAt)]
    });
  }
}