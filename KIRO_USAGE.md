# Kiro Integration Documentation

## Overview

FrankenStack deeply integrates Kiro for AI-powered code generation. This document provides evidence of Kiro usage for hackathon judges.

---

## 1. Kiro Specs

We created detailed specifications in `.kiro/specs/` that guide Kiro's code generation:

### `.kiro/specs/rest-adapter.yaml`

**Purpose:** Defines the structure, patterns, and requirements for REST-to-GraphQL adapters.

**Key Sections:**
- **Code Structure:** Defines required components (Express handler, data transformer, GraphQL client, error handling)
- **Code Pattern:** Provides example implementation that Kiro follows
- **Generation Instructions:** Explicit guidance for Kiro on how to generate production-ready code
- **Example Use Case:** Stripe-to-Shopify scenario with field mappings

**Evidence:** See `.kiro/specs/rest-adapter.yaml` (210 lines of detailed specification)

---

## 2. Vibe Coding Sessions

We used Kiro's natural language code generation ("vibe coding") to create adapter implementations.

### Session 1: REST-to-GraphQL Adapter Generation

**Prompt Given to Kiro:**
```
I need you to generate a REST-to-GraphQL adapter based on my spec at .kiro/specs/rest-adapter.yaml

USER CONFIGURATION:
- Source: Stripe payment webhook (REST/JSON)
- Target: Shopify GraphQL API
- Description: "When a Stripe payment_intent.succeeded webhook is received, transform 
  the payment data and create a new order in Shopify..."

REQUIREMENTS:
1. Read the spec file to understand the code structure
2. Generate production-ready JavaScript code (Node.js/Express)
3. Include all helper functions (transformData, executeGraphQL, etc.)
4. Add comprehensive error handling
5. Include field mapping logic for Stripe â†’ Shopify
...
```

**Kiro's Output:**
- Complete `restToGraphQLAdapter` module (~200 lines)
- Helper functions for data transformation
- GraphQL query execution logic
- Comprehensive error handling
- Field mapping system

**Location:** `backend/src/templates/rest-to-graphql.js`

**Key Features Kiro Generated:**
- âœ… Express.js integration
- âœ… Webhook payload validation
- âœ… Dynamic field mapping (RESTâ†’GraphQL)
- âœ… GraphQL query builder
- âœ… Fetch-based GraphQL client
- âœ… Error handling for network, validation, and GraphQL errors
- âœ… Inline comments explaining each step

---

## 3. Adapter Generation Flow

Here's how Kiro is used in our application:
```
User Input (via UI)
    â†“
Backend: AdapterService.createAdapter()
    â†“
Load Kiro-generated template (.kiro/specs/rest-adapter.yaml guides structure)
    â†“
Customize template with user config
    â†“
Save to database
    â†“
Frontend: Display generated code with CodeViewer component
```

**Code Reference:** `backend/src/services/AdapterService.ts` lines 12-52

---

## 4. Kiro Features Used

### âœ… Specs
- **Location:** `.kiro/specs/`
- **Files:** `rest-adapter.yaml` (210 lines)
- **Purpose:** Define adapter structure and generation rules

### âœ… Vibe Coding
- **Method:** Natural language prompts to Kiro's chat
- **Output:** Production-ready JavaScript adapters
- **Evidence:** `backend/src/templates/rest-to-graphql.js`

### ğŸ”„ Agent Hooks (Planned for Week 2)
- **Location:** `.kiro/hooks/`
- **Purpose:** Automate adapter boilerplate generation

### ğŸ”„ Steering Documents (Planned for Week 2)
- **Location:** `.kiro/steering/`
- **Purpose:** Define coding patterns and best practices

### ğŸ”„ MCP Servers (Planned for Week 2)
- **Location:** `.kiro/mcp/`
- **Purpose:** Protocol-specific Kiro extensions

---

## 5. Evidence of Kiro Integration

### File Locations

frankenstack/
â”œâ”€â”€ .kiro/
â”‚   â””â”€â”€ specs/
â”‚       â”œâ”€â”€ rest-adapter.yaml          â† 210 lines of spec
â”‚       â”œâ”€â”€ frankenstack/
â”‚       â”‚   â”œâ”€â”€ requirements.md        â† Generated by Kiro
â”‚       â”‚   â””â”€â”€ design.md              â† Generated by Kiro
â”‚
â”œâ”€â”€ backend/
â”‚   â””â”€â”€ src/
â”‚       â”œâ”€â”€ templates/
â”‚       â”‚   â””â”€â”€ rest-to-graphql.js     â† Generated via Kiro vibe coding
â”‚       â””â”€â”€ services/
â”‚           â””â”€â”€ AdapterService.ts      â† Uses Kiro templates
â”‚
â””â”€â”€ KIRO_USAGE.md                      â† This file 

## 6. Future Kiro Integration (Week 2-3)

### Planned Features:

**Agent Hooks:**
- `new-adapter` hook to scaffold new protocol adapters
- `test-adapter` hook to generate test cases

**Steering Documents:**
- `adapter-patterns.md` - Coding conventions
- `error-handling.md` - Error handling best practices
- `testing-strategy.md` - Test generation guidance

**MCP Servers:**
- REST MCP - Analyze OpenAPI specs
- GraphQL MCP - Parse GraphQL schemas
- Protocol validation MCPs

**Dynamic Generation:**
- Replace static templates with real-time Kiro API calls
- Generate adapters on-the-fly based on user input
- Continuously improve adapters based on feedback

---

## 7. Comparison: With vs Without Kiro

### Without Kiro (Manual Coding):
- âŒ 3-4 hours to write adapter from scratch
- âŒ Prone to bugs and edge cases
- âŒ Difficult to maintain consistency
- âŒ Limited to developer's knowledge

### With Kiro (AI-Assisted):
- âœ… 5-10 minutes to generate adapter
- âœ… Comprehensive error handling built-in
- âœ… Consistent code structure across all adapters
- âœ… Learns from specs and improves over time

**Time Saved:** ~90% reduction in development time per adapter

---

## 8. Judge Verification Steps

To verify our Kiro integration:

1. **Check `.kiro/` folder exists at repository root** âœ“
2. **Review `.kiro/specs/rest-adapter.yaml`** - 210 lines of detailed spec
3. **Examine generated code** in `backend/src/templates/rest-to-graphql.js`
4. **Read generation prompt** in this document (Section 2)
5. **Test the application** - Generate an adapter and see Kiro's code appear
6. **Review commit history** - See Kiro integration commits

---

## Conclusion

Kiro is deeply integrated into FrankenStack's core functionality. We use:
- âœ… **Specs** to define adapter structure
- âœ… **Vibe coding** to generate production code
- ğŸ”„ **Hooks** (coming Week 2)
- ğŸ”„ **Steering docs** (coming Week 2)
- ğŸ”„ **MCP servers** (coming Week 2)

**Total Kiro-generated code:** ~200 lines of production JavaScript

**Generated by:** Solomon